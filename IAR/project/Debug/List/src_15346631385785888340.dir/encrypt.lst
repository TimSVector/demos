###############################################################################
#
# IAR ANSI C/C++ Compiler V9.60.2.399/W64 for ARM         24/Sep/2025  10:21:31
# Copyright 1999-2024 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        D:\vector\customers\snph\IAR\code\encrypt\src\encrypt.c
#    Command line                 =
#        -f
#        D:\vector\customers\snph\IAR\Debug\Obj\src_15346631385785888340.dir\encrypt.o.rsp
#        (D:\vector\customers\snph\IAR\code\encrypt\src\encrypt.c -lC
#        D:\vector\customers\snph\IAR\Debug\List\src_15346631385785888340.dir
#        -o D:\vector\customers\snph\IAR\Debug\Obj\src_15346631385785888340.dir
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --libc++ -I
#        D:\vector\customers\snph\IAR\code\database\inc\ -I
#        D:\vector\customers\snph\IAR\code\encrypt\inc\ -I
#        D:\vector\customers\snph\IAR\code\order_entry\inc\ -I
#        D:\vector\customers\snph\IAR\code\utils\inc\ -On) --dependencies=n
#        D:\vector\customers\snph\IAR\Debug\Obj\src_15346631385785888340.dir\encrypt.o.iar_deps
#    Locale                       =  C
#    List file                    =
#        D:\vector\customers\snph\IAR\Debug\List\src_15346631385785888340.dir\encrypt.lst
#    Object file                  =
#        D:\vector\customers\snph\IAR\Debug\Obj\src_15346631385785888340.dir\encrypt.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  1
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#      __iar_require _Printf      =  flags,widths
#
###############################################################################

D:\vector\customers\snph\IAR\code\encrypt\src\encrypt.c
      1          /***************************************************************************************
      2           * Unit: encrypt.c                                                                     *
      3           *                                                                                     *
      4           * Purpose: Provides psuedo encryption services                                        *
      5           *                                                                                     *
      6           * Public API:                                                                         *
      7           *      - void Add_Included_Dessert(struct order_type* Order)                          *
      8           *                                                                                     *
      9           * Private API:                                                                        *
     10           *      - None                                        *                                *
     11           *                                                                                     *
     12           *                                                                                     *
     13           ***************************************************************************************/
     14          
     15          /***************************************************************************************
     16           *                            Program Headers                                          *
     17           ***************************************************************************************/
     18          
     19          #include "ctypes.h"
     20          #include "matrix_multiply.h"
     21          
     22          /***************************************************************************************
     23           *                            External Defintions                                      *
     24           ***************************************************************************************/
     25          
     26          
     27          #ifdef USING_TRUST_ZONE
     28          struct matrix_t TZ_Get_Private_Key(void);
     29          uint32_t TZ_Write_Data(struct matrix_t);
     30          uint32_t TZ_Reset_Hardware(uint32_t);
     31          void log_Error(const int8_t *, uint32_t);
     32          uint32_t TZ_Wait_Reset(uint32_t);
     33          void __SystemReset(const int8_t *);
     34          #define ON_ERROR 1
     35          #define TIMEOUT_10MSEC 1000
     36          #endif
     37          
     38          /***************************************************************************************
     39           *                            Private Prototypes                                       *
     40           ***************************************************************************************/
     41          static uint32_t sendData(const struct matrix_t data);
     42          static struct matrix_t generate_private_key(void);
     43          static uint32_t Encrypt_Info(const struct matrix_t* private_key, const int8_t * name, const int8_t number[16], const int8_t secCode[3], const uint32_t total);
     44          static uint32_t encrypt_and_send(const int8_t * inData, const uint32_t row, const uint32_t col,  const struct matrix_t * private_key);
     45          
     46          /**************************************************************************************
     47           *  Subprogram: sendData                                                              *
     48           *                                                                                    * 
     49           *  Purpose: Sesnd the "encrypted" data to the appropriate place                      *
     50           *                                                                                    * 
     51           *  Inputs:                                                                           *
     52           *       - data - struct matrix_t                                                     *
     53           *                                                                                    * 
     54           *  Outputs:                                                                          *
     55           *       - uint32_t - SUCCESS/FAILURE                                                 *
     56           *                                                                                    * 
     57           **************************************************************************************/
     58          

   \                                 In section .text, align 2, keep-with-next
     59          static uint32_t sendData(const struct matrix_t data) {
   \                     sendData: (+1)
   \        0x0   0xB40F             PUSH     {R0-R3}
   \        0x2   0xB570             PUSH     {R4-R6,LR}
     60                  uint32_t ret_val = SUCCESS;
   \        0x4   0x2400             MOVS     R4,#+0
     61          
     62          #ifdef USING_TRUST_ZONE
     63                  static uint32_t failureCount = 0;
     64                  ret_val = TZ_Write_Data(data);
     65                  // send data via the Trust Zone Data Write
     66                  if (ret_val == FAILURE && failureCount < 10) {
     67                      log_Error("Trust Zone Write Error", ++failureCount);
     68                      TZ_Reset_Hardware(ON_ERROR);
     69                      while (TZ_Wait_Reset(TIMEOUT_10MSEC)) ;    // loop until TZ resets                    
     70                  }
     71                  if (failureCount >= 10) __SystemReset("Encryption Failure");
     72                  return ret_val;
     73          #else
     74                  // display result matrix
     75                  //-e534
     76                  printf ("ENCRYPTED DATA (%dx%d): ", data.row, data.col);
   \        0x6   0x9A05             LDR      R2,[SP, #+20]
   \        0x8   0x9904             LDR      R1,[SP, #+16]
   \        0xA   0x....             LDR.N    R0,??DataTable2_1
   \        0xC   0x.... 0x....      BL       printf
     77          
     78                  for (uint32_t i = 0; (i < data.row) && (i < MAX_MATRIX); i++)
   \       0x10   0x2500             MOVS     R5,#+0
   \                     ??sendData_0: (+1)
   \       0x12   0x9804             LDR      R0,[SP, #+16]
   \       0x14   0x4285             CMP      R5,R0
   \       0x16   0xD214             BCS.N    ??sendData_1
   \       0x18   0x2D04             CMP      R5,#+4
   \       0x1A   0xD212             BCS.N    ??sendData_1
     79                      for (uint32_t j = 0; (j < data.col) && (j < MAX_MATRIX); j++)
   \       0x1C   0x2600             MOVS     R6,#+0
   \                     ??sendData_2: (+1)
   \       0x1E   0x9805             LDR      R0,[SP, #+20]
   \       0x20   0x4286             CMP      R6,R0
   \       0x22   0xD20C             BCS.N    ??sendData_3
   \       0x24   0x2E04             CMP      R6,#+4
   \       0x26   0xD20A             BCS.N    ??sendData_3
     80                          printf ("%02X ",data.matrix[i][j]);
   \       0x28   0xA804             ADD      R0,SP,#+16
   \       0x2A   0x0129             LSLS     R1,R5,#+4
   \       0x2C   0x4408             ADD      R0,R0,R1
   \       0x2E   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \       0x32   0x6881             LDR      R1,[R0, #+8]
   \       0x34   0x....             LDR.N    R0,??DataTable2_2
   \       0x36   0x.... 0x....      BL       printf
   \       0x3A   0x1C76             ADDS     R6,R6,#+1
   \       0x3C   0xE7EF             B.N      ??sendData_2
   \                     ??sendData_3: (+1)
   \       0x3E   0x1C6D             ADDS     R5,R5,#+1
   \       0x40   0xE7E7             B.N      ??sendData_0
     81                          
     82                  printf ("\n");
   \                     ??sendData_1: (+1)
   \       0x42   0x....             ADR.N    R0,??DataTable2
   \       0x44   0x.... 0x....      BL       printf
     83                  return ret_val;
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0xBC70             POP      {R4-R6}
   \       0x4C   0xF85D 0xFB14      LDR      PC,[SP], #+20
     84          #endif
     85          }
     86          /**************************************************************************************
     87           *  Subprogram: generate_private_key                                                  *
     88           *                                                                                    * 
     89           *  Purpose: Generate a "private" key                                                 *
     90           *                                                                                    * 
     91           *  Inputs:                                                                           *
     92           *       - None                                                                       *
     93           *                                                                                    * 
     94           *  Outputs:                                                                          *
     95           *       - struct matrix_t - random data for now                                      *
     96           *                                                                                    * 
     97           **************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     98          static struct matrix_t generate_private_key(void)
     99          {
   \                     generate_private_key: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    100              srand(0);
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x.... 0x....      BL       srand
    101          
    102              // set up default key
    103              static struct matrix_t private_key = {-1,-1,};
    104          
    105          #ifdef USING_TRUST_ZONE
    106              // use the hardware's trust zone to generate a private key
    107              private_key = TZ_Get_Private_Key();
    108          #else
    109           
    110              // if no data corruption has occurred...
    111              if ((private_key.row == -1) && (private_key.col == -1))
   \        0xA   0x....             LDR.N    R5,??DataTable2_3
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0xF110 0x0F01      CMN      R0,#+1
   \       0x12   0xD11D             BNE.N    ??generate_private_key_0
   \       0x14   0x6868             LDR      R0,[R5, #+4]
   \       0x16   0xF110 0x0F01      CMN      R0,#+1
   \       0x1A   0xD119             BNE.N    ??generate_private_key_0
    112              {
    113                  // set the private key to be 4x4
    114                  private_key.row = 4;
   \       0x1C   0x2004             MOVS     R0,#+4
   \       0x1E   0x6028             STR      R0,[R5, #+0]
    115                  private_key.col = 4;
   \       0x20   0x2004             MOVS     R0,#+4
   \       0x22   0x6068             STR      R0,[R5, #+4]
    116                  
    117                  // loop over the matrix rows
    118                  for (uint32_t i = 0; i < MAX_MATRIX; i++)
   \       0x24   0x2600             MOVS     R6,#+0
   \                     ??generate_private_key_1: (+1)
   \       0x26   0x2E04             CMP      R6,#+4
   \       0x28   0xD212             BCS.N    ??generate_private_key_0
    119                  {
    120                      // and loop over the matrix rows
    121                      for (uint32_t j = 0; j < MAX_MATRIX; j++)
   \       0x2A   0x2700             MOVS     R7,#+0
   \                     ??generate_private_key_2: (+1)
   \       0x2C   0x2F04             CMP      R7,#+4
   \       0x2E   0xD20D             BCS.N    ??generate_private_key_3
    122                      {
    123                          // store random data (for now)
    124                          private_key.matrix[i][j] = rand() % 0xff;
   \       0x30   0x.... 0x....      BL       rand
   \       0x34   0x21FF             MOVS     R1,#+255
   \       0x36   0x0132             LSLS     R2,R6,#+4
   \       0x38   0x442A             ADD      R2,R5,R2
   \       0x3A   0xEB02 0x0287      ADD      R2,R2,R7, LSL #+2
   \       0x3E   0xFB90 0xF3F1      SDIV     R3,R0,R1
   \       0x42   0xFB01 0x0013      MLS      R0,R1,R3,R0
   \       0x46   0x6090             STR      R0,[R2, #+8]
    125                      }
   \       0x48   0x1C7F             ADDS     R7,R7,#+1
   \       0x4A   0xE7EF             B.N      ??generate_private_key_2
    126                  }
   \                     ??generate_private_key_3: (+1)
   \       0x4C   0x1C76             ADDS     R6,R6,#+1
   \       0x4E   0xE7EA             B.N      ??generate_private_key_1
    127              }
    128          #endif
    129              // return the private key
    130              return private_key;
   \                     ??generate_private_key_0: (+1)
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x0029             MOVS     R1,R5
   \       0x54   0x2248             MOVS     R2,#+72
   \       0x56   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x5A   0xBDF1             POP      {R0,R4-R7,PC}
    131          }

   \                                 In section .data, align 4
   \                     `generate_private_key::private_key`:
   \        0x0   0xFFFF'FFFF        DC32 4'294'967'295, 4'294'967'295, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0xFFFF'FFFF  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
   \       0x38   0x0000'0000        DC32 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000
    132          
    133          /**************************************************************************************
    134           *  Subprogram: encrypt_and_send                                                      *
    135           *                                                                                    * 
    136           *  Purpose: Encrypts the information and transmits it                                * 
    137           *  Inputs:                                                                           *
    138           *       - inData - const int8_t *                                                    *
    139           *       - row - uint32_t                                                             *
    140           *       - column - uint32_t                                                          *
    141           *       - private_key - void *                                                       *
    142           *                                                                                    * 
    143           *  Outputs:                                                                          *
    144           *       - uint32_t - SUCCESS/FAILURE                                                 *
    145           *                                                                                    * 
    146           **************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    147           static uint32_t encrypt_and_send(const int8_t * inData, const uint32_t row, const uint32_t col,  const struct matrix_t * private_key)  
    148           {
   \                     encrypt_and_send: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB0B2             SUB      SP,SP,#+200
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    149               
    150              uint32_t ret_val;
    151              
    152              // Initialize the local variables
    153              struct matrix_t data2BSent = NULL_MATRIX;
   \        0xC   0xA820             ADD      R0,SP,#+128
   \        0xE   0x....             LDR.N    R1,??DataTable2_4
   \       0x10   0x2248             MOVS     R2,#+72
   \       0x12   0x.... 0x....      BL       __aeabi_memcpy4
    154              struct matrix_t result     = NULL_MATRIX;
   \       0x16   0xA80E             ADD      R0,SP,#+56
   \       0x18   0x....             LDR.N    R1,??DataTable2_5
   \       0x1A   0x2248             MOVS     R2,#+72
   \       0x1C   0x.... 0x....      BL       __aeabi_memcpy4
    155              
    156              // sets the data into the out matrix
    157              if (inData != NULL)   
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD02A             BEQ.N    ??encrypt_and_send_0
    158              {                                                             
    159                  uint32_t inEnd = 0;                                              
   \       0x24   0x2000             MOVS     R0,#+0
    160                  for (uint32_t i = 0; i < row; i++) {            
   \       0x26   0x2200             MOVS     R2,#+0
   \                     ??encrypt_and_send_1: (+1)
   \       0x28   0x42AA             CMP      R2,R5
   \       0x2A   0xD224             BCS.N    ??encrypt_and_send_2
    161                      for (uint32_t j = 0; j < col ; j++) {                                                       
   \       0x2C   0x2300             MOVS     R3,#+0
   \                     ??encrypt_and_send_3: (+1)
   \       0x2E   0x42B3             CMP      R3,R6
   \       0x30   0xD21F             BCS.N    ??encrypt_and_send_4
    162                          if (*inData == 0) {
   \       0x32   0xF994 0x1000      LDRSB    R1,[R4, #+0]
   \       0x36   0x2900             CMP      R1,#+0
   \       0x38   0xD101             BNE.N    ??encrypt_and_send_5
    163                              inEnd = 1;                                      
   \       0x3A   0x2101             MOVS     R1,#+1
   \       0x3C   0x0008             MOVS     R0,R1
    164                          }
    165                          if (inEnd > 0) {
   \                     ??encrypt_and_send_5: (+1)
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD00B             BEQ.N    ??encrypt_and_send_6
    166                              data2BSent.matrix[i][j] = *inData;               
   \       0x42   0xA920             ADD      R1,SP,#+128
   \       0x44   0xEA5F 0x1C02      LSLS     R12,R2,#+4
   \       0x48   0x4461             ADD      R1,R1,R12
   \       0x4A   0xEB01 0x0183      ADD      R1,R1,R3, LSL #+2
   \       0x4E   0xF994 0xC000      LDRSB    R12,[R4, #+0]
   \       0x52   0xF8C1 0xC008      STR      R12,[R1, #+8]
    167                              inData++;
   \       0x56   0x1C64             ADDS     R4,R4,#+1
   \       0x58   0xE009             B.N      ??encrypt_and_send_7
    168                          } else {
    169                              data2BSent.matrix[i][j] = 0;                       
   \                     ??encrypt_and_send_6: (+1)
   \       0x5A   0xA920             ADD      R1,SP,#+128
   \       0x5C   0xEA5F 0x1C02      LSLS     R12,R2,#+4
   \       0x60   0x4461             ADD      R1,R1,R12
   \       0x62   0xEB01 0x0183      ADD      R1,R1,R3, LSL #+2
   \       0x66   0xF05F 0x0C00      MOVS     R12,#+0
   \       0x6A   0xF8C1 0xC008      STR      R12,[R1, #+8]
    170                          }
    171                      }                                                       
   \                     ??encrypt_and_send_7: (+1)
   \       0x6E   0x1C5B             ADDS     R3,R3,#+1
   \       0x70   0xE7DD             B.N      ??encrypt_and_send_3
    172                  }
   \                     ??encrypt_and_send_4: (+1)
   \       0x72   0x1C52             ADDS     R2,R2,#+1
   \       0x74   0xE7D8             B.N      ??encrypt_and_send_1
    173                  data2BSent.row = row;                                        
   \                     ??encrypt_and_send_2: (+1)
   \       0x76   0x9520             STR      R5,[SP, #+128]
    174                  data2BSent.col = col;                                        
   \       0x78   0x9621             STR      R6,[SP, #+132]
    175              } 
    176              
    177              // call the matrix multiply routine to encrypt the data
    178              if (matrix_multiply(&data2BSent, private_key, &result) == FAILURE)
   \                     ??encrypt_and_send_0: (+1)
   \       0x7A   0xAA0E             ADD      R2,SP,#+56
   \       0x7C   0x0039             MOVS     R1,R7
   \       0x7E   0xA820             ADD      R0,SP,#+128
   \       0x80   0x.... 0x....      BL       matrix_multiply
   \       0x84   0xF110 0x0F01      CMN      R0,#+1
   \       0x88   0xD102             BNE.N    ??encrypt_and_send_8
    179              {
    180                  // if the matrix multiply failed, return FAILURE
    181                  ret_val = FAILURE;
   \       0x8A   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x8E   0xE008             B.N      ??encrypt_and_send_9
    182              } else {
    183                  ret_val = sendData(result);
   \                     ??encrypt_and_send_8: (+1)
   \       0x90   0xA90E             ADD      R1,SP,#+56
   \       0x92   0xB084             SUB      SP,SP,#+16
   \       0x94   0x4668             MOV      R0,SP
   \       0x96   0x2248             MOVS     R2,#+72
   \       0x98   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x9C   0xBC0F             POP      {R0-R3}
   \       0x9E   0x.... 0x....      BL       sendData
    184              }
    185          
    186              // otherwise send the data
    187              return ret_val;
   \                     ??encrypt_and_send_9: (+1)
   \       0xA2   0xB033             ADD      SP,SP,#+204
   \       0xA4   0xBDF0             POP      {R4-R7,PC}
    188           }
    189           
    190          /**************************************************************************************
    191           *  Subprogram: Encrypt_Info                                                          *
    192           *                                                                                    * 
    193           *  Purpose: Encrypts the credit card information and transmits it in chucks          * 
    194           *  Inputs:                                                                           *
    195           *       - private_key - void *                                                       *
    196           *       - name        - const int8_t *                                               *
    197           *       - number      - const int8_t[16]                                             *
    198           *       - secCode     - const int8_t [3]                                             *
    199           *       - Info  - float_t                                                            *
    200           *                                                                                    * 
    201           *  Outputs:                                                                          *
    202           *       - uint32_t - SUCCESS/FAILURE                                                 *
    203           *                                                                                    * 
    204           **************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    205          static uint32_t Encrypt_Info(const struct matrix_t* private_key, const int8_t * name, const int8_t number[16], const int8_t secCode[3],  const uint32_t total)
    206          {
   \                     Encrypt_Info: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x001F             MOVS     R7,R3
   \        0xA   0x9D0C             LDR      R5,[SP, #+48]
    207              // init the return value
    208              uint32_t ret_val = SUCCESS;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
    209              
    210              // send the name
    211              if ((name != NULL) && (total > 0)){
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD033             BEQ.N    ??Encrypt_Info_0
   \       0x14   0x2D00             CMP      R5,#+0
   \       0x16   0xD031             BEQ.N    ??Encrypt_Info_0
    212              
    213                  ret_val |= encrypt_and_send(name    , MAX_MATRIX, MAX_MATRIX, private_key);
   \       0x18   0x0033             MOVS     R3,R6
   \       0x1A   0x2204             MOVS     R2,#+4
   \       0x1C   0x2104             MOVS     R1,#+4
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       encrypt_and_send
   \       0x24   0x4681             MOV      R9,R0
   \       0x26   0xEA59 0x0908      ORRS     R9,R9,R8
    214                  ret_val |= encrypt_and_send(number  , MAX_MATRIX, MAX_MATRIX, private_key);
   \       0x2A   0x0033             MOVS     R3,R6
   \       0x2C   0x2204             MOVS     R2,#+4
   \       0x2E   0x2104             MOVS     R1,#+4
   \       0x30   0x9802             LDR      R0,[SP, #+8]
   \       0x32   0x.... 0x....      BL       encrypt_and_send
   \       0x36   0x4682             MOV      R10,R0
   \       0x38   0xEA5A 0x0A09      ORRS     R10,R10,R9
    215                  ret_val |= encrypt_and_send(secCode , 1         , MAX_MATRIX, private_key);
   \       0x3C   0x0033             MOVS     R3,R6
   \       0x3E   0x2204             MOVS     R2,#+4
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x0038             MOVS     R0,R7
   \       0x44   0x.... 0x....      BL       encrypt_and_send
   \       0x48   0x4683             MOV      R11,R0
   \       0x4A   0xEA5B 0x0B0A      ORRS     R11,R11,R10
    216                  
    217                  // send the total
    218                  uint8_t byteArray[4];
    219                  byteArray[0] = (uint8_t)  (total & 0x000000FFU);
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0xF88D 0x0000      STRB     R0,[SP, #+0]
    220                  byteArray[1] = (uint8_t) ((total & 0x0000FF00U) >> 8U);
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0x0A00             LSRS     R0,R0,#+8
   \       0x58   0xF88D 0x0001      STRB     R0,[SP, #+1]
    221                  byteArray[2] = (uint8_t) ((total & 0x00FF0000U) >> 16U);
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0x0C00             LSRS     R0,R0,#+16
   \       0x60   0xF88D 0x0002      STRB     R0,[SP, #+2]
    222                  byteArray[3] = (uint8_t) ((total & 0x00FF0000U) >> 24U);
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF88D 0x0003      STRB     R0,[SP, #+3]
    223                  
    224                  ret_val |= encrypt_and_send((const int8_t *)&byteArray, MAX_MATRIX, MAX_MATRIX, private_key);
   \       0x6A   0x0033             MOVS     R3,R6
   \       0x6C   0x2204             MOVS     R2,#+4
   \       0x6E   0x2104             MOVS     R1,#+4
   \       0x70   0x4668             MOV      R0,SP
   \       0x72   0x.... 0x....      BL       encrypt_and_send
   \       0x76   0xEA50 0x000B      ORRS     R0,R0,R11
   \       0x7A   0x4680             MOV      R8,R0
    225              }
    226          
    227              //static uint32_t encrypt_and_send(const int8_t * inData, const uint32_t row, const uint32_t col,  const struct matrix_t * private_key)  
    228              
    229              // return SUCCESS/FAILURE
    230              return ret_val;
   \                     ??Encrypt_Info_0: (+1)
   \       0x7C   0x4640             MOV      R0,R8
   \       0x7E   0xE8BD 0x8FFE      POP      {R1-R11,PC}
    231          }
    232          
    233          /**************************************************************************************
    234           *  Subprogram: transmit_Info                                                      *
    235           *                                                                                    * 
    236           *  Purpose: Transmit the credit card information                                     *
    237           *                                                                                    * 
    238           *  Inputs:                                                                           *
    239           *       - name        - const int8_t *                                                 *
    240           *       - number      - const int8_t[16]                                               *
    241           *       - secCode     - const int8_t [3]                                               *
    242           *       - Info        - float_t                                                        *
    243           *                                                                                    * 
    244           *  Outputs:                                                                          *
    245           *       - uint32_t - SUCCESS/FAILURE                                                      *
    246           *                                                                                    * 
    247           **************************************************************************************/
    248          

   \                                 In section .text, align 2, keep-with-next
    249          uint32_t transmit_Info (const int8_t * name, const int8_t number[16], const int8_t secCode[3], float_t Info)
    250          {
   \                     transmit_Info: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xED2D 0x8B02      VPUSH    {D8}
   \        0x6   0xB0A4             SUB      SP,SP,#+144
   \        0x8   0x0004             MOVS     R4,R0
   \        0xA   0x000D             MOVS     R5,R1
   \        0xC   0x0016             MOVS     R6,R2
   \        0xE   0xEEB0 0x8A40      VMOV.F32 S16,S0
    251              // generate a private key
    252              const struct matrix_t private_key = generate_private_key();
   \       0x12   0x4668             MOV      R0,SP
   \       0x14   0x.... 0x....      BL       generate_private_key
   \       0x18   0xA812             ADD      R0,SP,#+72
   \       0x1A   0x4669             MOV      R1,SP
   \       0x1C   0x2248             MOVS     R2,#+72
   \       0x1E   0x.... 0x....      BL       __aeabi_memcpy4
    253          
    254              const uint32_t total = (uint32_t) Info * 100;
   \       0x22   0xEEBC 0x0AC8      VCVT.U32.F32 S0,S16
   \       0x26   0xEE10 0x0A10      VMOV     R0,S0
   \       0x2A   0x2764             MOVS     R7,#+100
   \       0x2C   0xFB07 0xF700      MUL      R7,R7,R0
    255          
    256              // Encrypt and send the data
    257              return Encrypt_Info(&private_key,name,number,secCode, total);
   \       0x30   0x9700             STR      R7,[SP, #+0]
   \       0x32   0x0033             MOVS     R3,R6
   \       0x34   0x002A             MOVS     R2,R5
   \       0x36   0x0021             MOVS     R1,R4
   \       0x38   0xA812             ADD      R0,SP,#+72
   \       0x3A   0x.... 0x....      BL       Encrypt_Info
   \       0x3E   0xB024             ADD      SP,SP,#+144
   \       0x40   0xECBD 0x8B02      VPOP     {D8}
   \       0x44   0xBDF2             POP      {R1,R4-R7,PC}
    258             
    259          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x0A 0x00          DC8      "\n",0x0,0x0   
   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x....'....        DC32     `generate_private_key::private_key`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x45 0x4E          DC8 "ENCRYPTED DATA (%dx%d): "
   \              0x43 0x52    
   \              0x59 0x50    
   \              0x54 0x45    
   \              0x44 0x20    
   \              0x44 0x41    
   \              0x54 0x41    
   \              0x20 0x28    
   \              0x25 0x64    
   \              0x78 0x25    
   \              0x64 0x29    
   \              0x3A 0x20    
   \              0x00
   \       0x19                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x25 0x30          DC8 "%02X "
   \              0x32 0x58    
   \              0x20 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 2
   \        0x0   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x0000'0004        DC32 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000'0004  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x0000'0004        DC32 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000'0004  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   Encrypt_Info
        48   -> encrypt_and_send
     240   encrypt_and_send
       224   -> __aeabi_memcpy4
       240   -> __aeabi_memcpy4
       224   -> matrix_multiply
       224   -> sendData
      24   generate_private_key
        24   -> __aeabi_memcpy4
        24   -> rand
        24   -> srand
      32   sendData
        32   -> printf
     176   transmit_Info
       176   -> Encrypt_Info
       176   -> __aeabi_memcpy4
       176   -> generate_private_key


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
      28  ?_0
       8  ?_1
       2  ?_2
      72  ?_3
      72  ?_4
     130  Encrypt_Info
     166  encrypt_and_send
      92  generate_private_key
      72  private_key
      80  sendData
      70  transmit_Info

 
  72 bytes in section .data
 182 bytes in section .rodata
 562 bytes in section .text
 
 562 bytes of CODE  memory
 182 bytes of CONST memory
  72 bytes of DATA  memory

Errors: none
Warnings: none
